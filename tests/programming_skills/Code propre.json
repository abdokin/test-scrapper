{
  "title": "Code propre : Principes et pratiques",
  "attributes": {
    "overview": "Ce test évalue la compréhension et l'application des principes de code propre, essentiels pour tout développeur souhaitant créer des logiciels maintenables et efficaces.",
    "level": "intermediate",
    "covered_skills": [
      "Principes SOLID",
      "Nommage significatif",
      "Gestion des commentaires",
      "Formatage du code",
      "Gestion des erreurs",
      "Conception de fonctions",
      "Refactoring",
      "Tests unitaires",
      "Gestion de la complexité",
      "Principes de conception",
      "Architecture logicielle",
      "Bonnes pratiques de codage"
    ],
    "relevancy": "Ce test est pertinent pour tous les postes de développement logiciel, quelle que soit la technologie utilisée.",
    "description": "Le test couvre les aspects fondamentaux et intermédiaires du code propre, évaluant la capacité du candidat à écrire un code lisible, maintenable et efficace.",
    "category": "Programming skills",
    "language": "french",
    "questions_to_answer": 15,
    "duration_seconds": 900,
    "position": 1
  },
  "questions": [
    {
      "question_attributes": {
        "type": "multiple_choice",
        "preview": true,
        "content": "Quel est le principal avantage d'un code propre ?"
      },
      "options": [
        {
          "content": "Facilité de maintenance",
          "correct": true
        },
        {
          "content": "Exécution plus rapide"
        },
        {
          "content": "Utilisation de moins de mémoire"
        },
        {
          "content": "Compatibilité avec tous les systèmes d'exploitation"
        }
      ]
    },
    {
      "question_attributes": {
        "type": "multiple_choice",
        "preview": true,
        "content": "Que signifie l'acronyme DRY en programmation ?"
      },
      "options": [
        {
          "content": "Don't Repeat Yourself",
          "correct": true
        },
        {
          "content": "Do Repeat Yourself"
        },
        {
          "content": "Don't Rewrite Yet"
        },
        {
          "content": "Do Review Yourself"
        }
      ]
    },
    {
      "question_attributes": {
        "type": "multiple_choice",
        "preview": true,
        "content": "Quelle est la meilleure pratique pour nommer une variable représentant un nombre de jours ?"
      },
      "options": [
        {
          "content": "nombreDeJours",
          "correct": true
        },
        {
          "content": "x"
        },
        {
          "content": "nj"
        },
        {
          "content": "variable1"
        }
      ]
    },
    {
      "question_attributes": {
        "type": "multiple_choice",
        "content": "Quel principe SOLID est violé si une classe a plus d'une raison de changer ?"
      },
      "options": [
        {
          "content": "Principe de responsabilité unique",
          "correct": true
        },
        {
          "content": "Principe ouvert/fermé"
        },
        {
          "content": "Principe de substitution de Liskov"
        },
        {
          "content": "Principe de ségrégation des interfaces"
        }
      ]
    },
    {
      "question_attributes": {
        "type": "multiple_choice",
        "content": "Quelle est la meilleure approche pour gérer la complexité dans une fonction ?"
      },
      "options": [
        {
          "content": "Diviser la fonction en plusieurs fonctions plus petites",
          "correct": true
        },
        {
          "content": "Utiliser plus de commentaires"
        },
        {
          "content": "Utiliser des noms de variables plus longs"
        },
        {
          "content": "Augmenter l'indentation"
        }
      ]
    },
    {
      "question_attributes": {
        "type": "multiple_choice",
        "content": "Quelle est la meilleure pratique concernant les commentaires dans le code ?"
      },
      "options": [
        {
          "content": "Utiliser des commentaires pour expliquer pourquoi, pas comment",
          "correct": true
        },
        {
          "content": "Commenter chaque ligne de code"
        },
        {
          "content": "Éviter complètement les commentaires"
        },
        {
          "content": "Utiliser des commentaires uniquement pour les fonctions complexes"
        }
      ]
    },
    {
      "question_attributes": {
        "type": "multiple_response",
        "content": "Quels sont les avantages d'un code propre ? (Sélectionnez toutes les réponses correctes)"
      },
      "options": [
        {
          "content": "Facilite la collaboration entre développeurs",
          "correct": true
        },
        {
          "content": "Réduit le temps nécessaire pour comprendre le code",
          "correct": true
        },
        {
          "content": "Diminue le risque d'introduire des bugs",
          "correct": true
        },
        {
          "content": "Augmente la vitesse d'exécution du code"
        }
      ]
    },
    {
      "question_attributes": {
        "type": "multiple_choice",
        "content": "Quelle est la meilleure pratique pour gérer les exceptions ?"
      },
      "options": [
        {
          "content": "Attraper les exceptions spécifiques plutôt que génériques",
          "correct": true
        },
        {
          "content": "Toujours utiliser un bloc try-catch"
        },
        {
          "content": "Ignorer les exceptions"
        },
        {
          "content": "Utiliser uniquement des exceptions génériques"
        }
      ]
    },
    {
      "question_attributes": {
        "type": "multiple_choice",
        "content": "Quel est le but principal du refactoring ?"
      },
      "options": [
        {
          "content": "Améliorer la structure interne du code sans modifier son comportement externe",
          "correct": true
        },
        {
          "content": "Ajouter de nouvelles fonctionnalités"
        },
        {
          "content": "Corriger les bugs"
        },
        {
          "content": "Optimiser les performances"
        }
      ]
    },
    {
      "question_attributes": {
        "type": "multiple_response",
        "content": "Quelles sont les bonnes pratiques pour écrire des fonctions propres ? (Sélectionnez toutes les réponses correctes)"
      },
      "options": [
        {
          "content": "Limiter le nombre de paramètres",
          "correct": true
        },
        {
          "content": "Avoir une seule responsabilité",
          "correct": true
        },
        {
          "content": "Éviter les effets de bord",
          "correct": true
        },
        {
          "content": "Toujours retourner une valeur"
        }
      ]
    },
    {
      "question_attributes": {
        "type": "multiple_choice",
        "content": "Quel est le principal avantage des tests unitaires dans le contexte du code propre ?"
      },
      "options": [
        {
          "content": "Ils servent de documentation vivante du code",
          "correct": true
        },
        {
          "content": "Ils remplacent les commentaires"
        },
        {
          "content": "Ils augmentent la performance du code"
        },
        {
          "content": "Ils réduisent la taille du code"
        }
      ]
    },
    {
      "question_attributes": {
        "type": "multiple_choice",
        "content": "Quelle est la meilleure approche pour gérer la duplication de code ?"
      },
      "options": [
        {
          "content": "Extraire le code dupliqué dans une fonction réutilisable",
          "correct": true
        },
        {
          "content": "Copier-coller le code là où il est nécessaire"
        },
        {
          "content": "Utiliser des commentaires pour expliquer la duplication"
        },
        {
          "content": "Ignorer la duplication si elle n'est pas trop importante"
        }
      ]
    },
    {
      "question_attributes": {
        "type": "multiple_response",
        "content": "Quels sont les principes SOLID ? (Sélectionnez toutes les réponses correctes)"
      },
      "options": [
        {
          "content": "Single Responsibility Principle",
          "correct": true
        },
        {
          "content": "Open/Closed Principle",
          "correct": true
        },
        {
          "content": "Liskov Substitution Principle",
          "correct": true
        },
        {
          "content": "Dependency Inversion Principle",
          "correct": true
        }
      ]
    },
    {
      "question_attributes": {
        "type": "multiple_choice",
        "content": "Quelle est la meilleure pratique pour le formatage du code ?"
      },
      "options": [
        {
          "content": "Utiliser un style cohérent dans tout le projet",
          "correct": true
        },
        {
          "content": "Laisser chaque développeur utiliser son propre style"
        },
        {
          "content": "Ne pas se soucier du formatage"
        },
        {
          "content": "Utiliser le moins d'espaces possible pour économiser de la mémoire"
        }
      ]
    },
    {
      "question_attributes": {
        "type": "multiple_choice",
        "content": "Quel est le principal avantage de l'utilisation de noms significatifs pour les variables et les fonctions ?"
      },
      "options": [
        {
          "content": "Cela rend le code auto-documenté",
          "correct": true
        },
        {
          "content": "Cela améliore les performances du code"
        },
        {
          "content": "Cela réduit la taille du code compilé"
        },
        {
          "content": "Cela permet d'éviter les tests unitaires"
        }
      ]
    },
    {
      "question_attributes": {
        "type": "multiple_response",
        "content": "Quelles sont les caractéristiques d'une bonne fonction ? (Sélectionnez toutes les réponses correctes)"
      },
      "options": [
        {
          "content": "Elle fait une seule chose",
          "correct": true
        },
        {
          "content": "Elle est courte",
          "correct": true
        },
        {
          "content": "Elle a un nom descriptif",
          "correct": true
        },
        {
          "content": "Elle contient beaucoup de commentaires"
        }
      ]
    },
    {
      "question_attributes": {
        "type": "multiple_choice",
        "content": "Quelle est la meilleure pratique pour gérer la complexité conditionnelle ?"
      },
      "options": [
        {
          "content": "Extraire les conditions complexes dans des fonctions bien nommées",
          "correct": true
        },
        {
          "content": "Utiliser des commentaires pour expliquer la logique"
        },
        {
          "content": "Imbriquer autant de conditions que nécessaire"
        },
        {
          "content": "Éviter complètement les structures conditionnelles"
        }
      ]
    },
    {
      "question_attributes": {
        "type": "multiple_choice",
        "content": "Quel est le principal avantage de l'utilisation de constantes nommées plutôt que de valeurs littérales dans le code ?"
      },
      "options": [
        {
          "content": "Cela améliore la lisibilité et la maintenabilité du code",
          "correct": true
        },
        {
          "content": "Cela améliore les performances du code"
        },
        {
          "content": "Cela réduit la taille du code compilé"
        },
        {
          "content": "Cela permet d'éviter les erreurs de compilation"
        }
      ]
    },
    {
      "question_attributes": {
        "type": "multiple_response",
        "content": "Quels sont les avantages de l'utilisation d'un outil de formatage automatique du code ? (Sélectionnez toutes les réponses correctes)"
      },
      "options": [
        {
          "content": "Assure la cohérence du style dans tout le projet",
          "correct": true
        },
        {
          "content": "Réduit les conflits lors des fusions de code",
          "correct": true
        },
        {
          "content": "Permet aux développeurs de se concentrer sur la logique plutôt que sur le formatage",
          "correct": true
        },
        {
          "content": "Corrige automatiquement les bugs logiques"
        }
      ]
    },
    {
      "question_attributes": {
        "type": "multiple_choice",
        "content": "Quel principe de conception encourage la composition plutôt que l'héritage ?"
      },
      "options": [
        {
          "content": "Favoriser la composition sur l'héritage",
          "correct": true
        },
        {
          "content": "Principe de responsabilité unique"
        },
        {
          "content": "Principe d'inversion de dépendance"
        },
        {
          "content": "Principe de substitution de Liskov"
        }
      ]
    },
    {
      "question_attributes": {
        "type": "multiple_choice",
        "content": "Quelle est la meilleure approche pour gérer la complexité cyclomatique élevée ?"
      },
      "options": [
        {
          "content": "Refactoriser le code en plusieurs fonctions plus petites",
          "correct": true
        },
        {
          "content": "Ajouter plus de commentaires"
        },
        {
          "content": "Augmenter la limite de complexité acceptée"
        },
        {
          "content": "Ignorer les avertissements de l'analyseur de code"
        }
      ]
    },
    {
      "question_attributes": {
        "type": "multiple_response",
        "content": "Quels sont les avantages de l'utilisation de l'injection de dépendances ? (Sélectionnez toutes les réponses correctes)"
      },
      "options": [
        {
          "content": "Facilite les tests unitaires",
          "correct": true
        },
        {
          "content": "Réduit le couplage entre les classes",
          "correct": true
        },
        {
          "content": "Améliore la flexibilité et la réutilisabilité du code",
          "correct": true
        },
        {
          "content": "Augmente la vitesse d'exécution du code"
        }
      ]
    },
    {
      "question_attributes": {
        "type": "multiple_choice",
        "content": "Quel est le principal avantage de l'utilisation des expressions lambda dans le code ?"
      },
      "options": [
        {
          "content": "Elles permettent d'écrire un code plus concis et lisible",
          "correct": true
        },
        {
          "content": "Elles améliorent toujours les performances du code"
        },
        {
          "content": "Elles remplacent complètement les boucles traditionnelles"
        },
        {
          "content": "Elles éliminent le besoin de classes anonymes"
        }
      ]
    },
    {
      "question_attributes": {
        "type": "multiple_choice",
        "content": "Quelle est la meilleure pratique pour gérer les erreurs dans un code propre ?"
      },
      "options": [
        {
          "content": "Utiliser des exceptions pour les cas exceptionnels et des codes de retour pour les erreurs attendues",
          "correct": true
        },
        {
          "content": "Toujours utiliser des exceptions pour toutes les erreurs"
        },
        {
          "content": "Utiliser uniquement des codes de retour pour toutes les erreurs"
        },
        {
          "content": "Ignorer la gestion des erreurs pour simplifier le code"
        }
      ]
    },
    {
      "question_attributes": {
        "type": "multiple_response",
        "content": "Quels sont les avantages de l'utilisation des interfaces dans un code propre ? (Sélectionnez toutes les réponses correctes)"
      },
      "options": [
        {
          "content": "Elles permettent de définir un contrat clair entre les classes",
          "correct": true
        },
        {
          "content": "Elles facilitent le polymorphisme",
          "correct": true
        },
        {
          "content": "Elles améliorent la modularité du code",
          "correct": true
        },
        {
          "content": "Elles augmentent toujours les performances du code"
        }
      ]
    },
    {
      "question_attributes": {
        "type": "multiple_choice",
        "content": "Quel est le principal avantage de l'utilisation des design patterns dans un code propre ?"
      },
      "options": [
        {
          "content": "Ils fournissent des solutions éprouvées à des problèmes récurrents",
          "correct": true
        },
        {
          "content": "Ils rendent le code plus rapide"
        },
        {
          "content": "Ils remplacent le besoin de documentation"
        },
        {
          "content": "Ils éliminent le besoin de tests unitaires"
        }
      ]
    },
    {
      "question_attributes": {
        "type": "multiple_choice",
        "content": "Quelle est la meilleure approche pour gérer la complexité dans une classe ?"
      },
      "options": [
        {
          "content": "Diviser la classe en plusieurs classes plus petites et spécialisées",
          "correct": true
        },
        {
          "content": "Ajouter plus de méthodes à la classe"
        },
        {
          "content": "Utiliser plus de variables globales"
        },
        {
          "content": "Augmenter l'héritage entre les classes"
        }
      ]
    },
    {
      "question_attributes": {
        "type": "multiple_response",
        "content": "Quels sont les avantages de l'utilisation des énumérations dans un code propre ? (Sélectionnez toutes les réponses correctes)"
      },
      "options": [
        {
          "content": "Elles améliorent la lisibilité du code",
          "correct": true
        },
        {
          "content": "Elles réduisent les erreurs liées aux constantes magiques",
          "correct": true
        },
        {
          "content": "Elles facilitent le refactoring",
          "correct": true
        },
        {
          "content": "Elles augmentent toujours les performances du code"
        }
      ]
    },
    {
      "question_attributes": {
        "type": "multiple_choice",
        "content": "Quel est le principal avantage de l'utilisation des assertions dans un code propre ?"
      },
      "options": [
        {
          "content": "Elles permettent de détecter rapidement les erreurs de programmation",
          "correct": true
        },
        {
          "content": "Elles remplacent les tests unitaires"
        },
        {
          "content": "Elles améliorent les performances du code"
        },
        {
          "content": "Elles simplifient la gestion des exceptions"
        }
      ]
    },
    {
      "question_attributes": {
        "type": "multiple_choice",
        "content": "Quelle est la meilleure pratique pour gérer les dépendances externes dans un code propre ?"
      },
      "options": [
        {
          "content": "Utiliser un gestionnaire de dépendances et définir clairement les versions requises",
          "correct": true
        },
        {
          "content": "Copier-coller le code des dépendances directement dans le projet"
        },
        {
          "content": "Toujours utiliser la dernière version disponible de chaque dépendance"
        },
        {
          "content": "Éviter complètement l'utilisation de dépendances externes"
        }
      ]
    },
    {
      "question_attributes": {
        "type": "multiple_response",
        "content": "Quels sont les avantages de l'utilisation de la programmation fonctionnelle dans un code propre ? (Sélectionnez toutes les réponses correctes)"
      },
      "options": [
        {
          "content": "Elle favorise l'immutabilité, réduisant les effets de bord",
          "correct": true
        },
        {
          "content": "Elle facilite le parallélisme et la concurrence",
          "correct": true
        },
        {
          "content": "Elle améliore la testabilité du code",
          "correct": true
        },
        {
          "content": "Elle élimine complètement le besoin de programmation orientée objet"
        }
      ]
    },
    {
      "question_attributes": {
        "type": "multiple_choice",
        "content": "Quel est le principal avantage de l'utilisation des generics dans un code propre ?"
      },
      "options": [
        {
          "content": "Ils permettent d'écrire du code réutilisable et type-safe",
          "correct": true
        },
        {
          "content": "Ils améliorent toujours les performances du code"
        },
        {
          "content": "Ils remplacent le besoin d'héritage"
        },
        {
          "content": "Ils simplifient la gestion des exceptions"
        }
      ]
    },
    {
      "question_attributes": {
        "type": "multiple_choice",
        "content": "Quelle est la meilleure pratique pour gérer la configuration dans un code propre ?"
      },
      "options": [
        {
          "content": "Utiliser des fichiers de configuration externes et injecter les valeurs dans le code",
          "correct": true
        },
        {
          "content": "Hardcoder les valeurs de configuration directement dans le code"
        },
        {
          "content": "Utiliser des variables d'environnement pour toutes les configurations"
        },
        {
          "content": "Demander à l'utilisateur de saisir les valeurs de configuration à chaque exécution"
        }
      ]
    },
    {
      "question_attributes": {
        "type": "multiple_response",
        "content": "Quels sont les avantages de l'utilisation des streams dans un code propre ? (Sélectionnez toutes les réponses correctes)"
      },
      "options": [
        {
          "content": "Ils permettent d'écrire un code plus déclaratif",
          "correct": true
        },
        {
          "content": "Ils facilitent le traitement parallèle des données",
          "correct": true
        },
        {
          "content": "Ils améliorent la lisibilité du code pour les opérations sur les collections",
          "correct": true
        },
        {
          "content": "Ils remplacent complètement le besoin de boucles traditionnelles"
        }
      ]
    },
    {
      "question_attributes": {
        "type": "multiple_choice",
        "content": "Quel est le principal avantage de l'utilisation des méthodes statiques dans un code propre ?"
      },
      "options": [
        {
          "content": "Elles permettent de regrouper des fonctionnalités utilitaires sans nécessiter d'instance",
          "correct": true
        },
        {
          "content": "Elles améliorent toujours les performances du code"
        },
        {
          "content": "Elles remplacent le besoin de classes non statiques"
        },
        {
          "content": "Elles facilitent la gestion de l'état global de l'application"
        }
      ]
    },
    {
      "question_attributes": {
        "type": "multiple_choice",
        "content": "Quelle est la meilleure pratique pour gérer les ressources (fichiers, connexions réseau, etc.) dans un code propre ?"
      },
      "options": [
        {
          "content": "Utiliser des blocs try-with-resources ou l'équivalent dans votre langage",
          "correct": true
        },
        {
          "content": "Fermer manuellement les ressources à la fin de chaque méthode"
        },
        {
          "content": "Laisser le garbage collector gérer la fermeture des ressources"
        },
        {
          "content": "Éviter d'utiliser des ressources externes pour simplifier le code"
        }
      ]
    },
    {
      "question_attributes": {
        "type": "multiple_response",
        "content": "Quels sont les avantages de l'utilisation des classes immuables dans un code propre ? (Sélectionnez toutes les réponses correctes)"
      },
      "options": [
        {
          "content": "Elles sont thread-safe par nature",
          "correct": true
        },
        {
          "content": "Elles simplifient le raisonnement sur le code",
          "correct": true
        },
        {
          "content": "Elles peuvent être utilisées en toute sécurité comme clés dans les collections",
          "correct": true
        },
        {
          "content": "Elles améliorent toujours les performances du code"
        }
      ]
    },
    {
      "question_attributes": {
        "type": "multiple_choice",
        "content": "Quel est le principal avantage de l'utilisation des annotations dans un code propre ?"
      },
      "options": [
        {
          "content": "Elles permettent d'ajouter des métadonnées au code de manière structurée",
          "correct": true
        },
        {
          "content": "Elles remplacent le besoin de documentation"
        },
        {
          "content": "Elles améliorent toujours les performances du code"
        },
        {
          "content": "Elles éliminent le besoin de tests unitaires"
        }
      ]
    },
    {
      "question_attributes": {
        "type": "multiple_choice",
        "content": "Quelle est la meilleure pratique pour gérer les variables globales dans un code propre ?"
      },
      "options": [
        {
          "content": "Éviter autant que possible l'utilisation de variables globales",
          "correct": true
        },
        {
          "content": "Utiliser des variables globales pour toutes les données partagées"
        },
        {
          "content": "Rendre toutes les variables globales publiques pour faciliter l'accès"
        },
        {
          "content": "Utiliser des variables globales uniquement pour les constantes"
        }
      ]
    }
  ]
}